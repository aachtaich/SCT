/*
 * generated by Xtext 2.10.0
 */
package org.xtext.example.stateconstrainttransition.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtend2.lib.StringConcatenation
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.CompositeState
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.EndTransition
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.FullTransition
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.Model
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.SimpleConstraintState
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.StartTransition
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.Variable

import static extension org.eclipse.xtext.nodemodel.util.NodeModelUtils.*
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.ConcernLevel
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.StateConstraint
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.Or_state
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.And_state
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.stateNameRef
/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class StateConstraintTransitionGenerator extends AbstractGenerator {

	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		resource.allContents.filter(typeof(Model)).forEach[it.generateCSP(fsa)]
	}
	
	
	def void generateCSP(Model statemachine, IFileSystemAccess2 fsa ){
		fsa.generateFile(statemachine.name+".mzn", statemachine.generate)
	} 


	def generate(Model statemachine) 
	'''
	include "globals.mzn";
	
	%Declaration of variables
	«FOR variable : statemachine.variable»
		«IF variable.isMultiInstanciated == null»
			«variable.TypeAllocation+variable.name»;
		«ELSE»
			«variable.createCardinalities+variable.name»;
		«ENDIF»
	«ENDFOR»
	
	%Flexing constraints from imported models
	«IF statemachine.flexConstraints != null»
		«statemachine.flexConstraint»
	«ENDIF»
	
	
	%Declaration of composite states and their Hierarchy
	«FOR globalState : statemachine.state.filter(SimpleConstraintState)»
		var 0..1:«globalState.name»;
	«ENDFOR»
	«FOR compositeState : statemachine.state.filter(CompositeState)»
		var 0..1:«compositeState.name»;
		«compositeState.statemachineDeclaration»
	«ENDFOR»
	
	«FOR compositeState : statemachine.state.filter(CompositeState)»
		«compositeState.GetSimpleStateConstraints»
	«ENDFOR»
	
	
	%Constraints---------------------------------------------------
		%on the hierarchy
	
	«FOR compositeState : statemachine.state.filter(CompositeState)»
		«compositeState.statemachineConstraints»
	«ENDFOR»
		%on full transitions
	
	«FOR fullTransition : statemachine.transition.filter(FullTransition)»
		«fullTransition.FullTransitionConstraints»
	«ENDFOR»
	
		%on start transitions
	«FOR startTransition : statemachine.transition.filter(StartTransition)»
		«startTransition.StartTransitionConstraints»
	«ENDFOR»
	
	«IF statemachine.flexConstraints != null»Aintnomore1++
	
		solve maximize Flex;
	«ELSE»	
		solve satisfy;
	«ENDIF»
	'''
	
	//generate flexible constraints«»«»
	def flexConstraint(Model statemachine)
	{	
		var count=1;
		var Flex=""
		val builder = new StringConcatenation();
		builder.append("var int: Flex;")
		builder.newLine()
		for (constraint : statemachine.flexConstraints)
		{
			builder.append("var 0..1: Flex"+count+";")
			builder.newLine()
			Flex += "Flex"+count+"+".toString
			builder.append("constraint Flex"+count+" = 1 <-> (")
			builder.append(constraint.getNode.getTokenText +");")
			builder.newLine()
			count=count+1;
		}
		builder.append("Flex = " +((Flex.toString).subSequence(0, (Flex.toString).length-1) )+";")
		return builder
	}

	
	//statemachineDeclaration declatres all states and concern levels as boolean variables
	def statemachineDeclaration (CompositeState compositeState)
	'''
		«FOR ConcernLevels : compositeState.concernlevel»
			var 0..1:«ConcernLevels.name»;
			«FOR compState : ConcernLevels.state.filter(CompositeState)»
				«IF compState!=null»
					var 0..1:«compState.name»;
					«compState.statemachineDeclaration»
				«ENDIF»
			«ENDFOR»
			«FOR SimpleState : ConcernLevels.state.filter(SimpleConstraintState)»
				var 0..1:«SimpleState.name»;
			«ENDFOR»
		«ENDFOR»
	'''
	
	def GetSimpleStateConstraints (CompositeState compositeState)
	'''
		«FOR ConcernLevels : compositeState.concernlevel»
			«FOR compState : ConcernLevels.state.filter(CompositeState)»
				«IF compState!=null»
					«compState.GetSimpleStateConstraints»
				«ENDIF»
			«ENDFOR»
			«FOR SimpleState : ConcernLevels.state.filter(SimpleConstraintState)»
				constraint «SimpleState.name» = 1 -> («SimpleState.getConstraints»);
			«ENDFOR»
		«ENDFOR»
	'''
	
	//statemachineConstraints constraints the states and concern levels, depending on their hierarchy
	def statemachineConstraints (CompositeState compositeState)
	'''
		«var sumOfCLinCS=""»
		«var sumOfStatesInCL=""»
		«var sumOfStatesInCS=""»
		«FOR ConcernLevels : compositeState.concernlevel»
			constraint «compositeState.name» = 1 <-> «ConcernLevels.name» = 1;
			«sumOfStatesInCL=""»
			constraint «ConcernLevels.name» = «ConcernLevels.sumOfStatesInCL» ;
			«FOR compState : ConcernLevels.state.filter(CompositeState)»
				«IF compState!=null»
					«compState.statemachineConstraints»
				«ENDIF»
			«ENDFOR»
		«ENDFOR»
		constraint «compositeState.sumOfStatesInCS(sumOfStatesInCS)» =  «compositeState.name»  * ( «compositeState.sumOfCLinCS» );
	'''
	
	def sumOfCLinCS (CompositeState compositeState)
	{
		var count =0
		var sumOfCLinCS=""
		for(ConcernLevels : compositeState.concernlevel)
		{
			count = count+1
		}
		for(ConcernLevels : compositeState.concernlevel)
		{
			if (count>1)
				sumOfCLinCS += ConcernLevels.name + " + "
			else 
				sumOfCLinCS += ConcernLevels.name +"  "
		}
		return sumOfCLinCS.subSequence(0, sumOfCLinCS.length-2)
	}
	
	def sumOfStatesInCL (ConcernLevel concernLevel)
	{
		var sumOfStatesInCL=""
		var count =0
		for(state : concernLevel.state)
			{
				count = count+1
			}
		for(state : concernLevel.state)
			{
				if (count>1)
					sumOfStatesInCL += state.name + " + "
				else 
					sumOfStatesInCL += state.name +"  "
			}
		return sumOfStatesInCL.subSequence(0, sumOfStatesInCL.length-2)
	}
	
	def sumOfStatesInCS (CompositeState compositeState, String SumStatesInCS )
	{
		var count =0
		var StatesInCS=SumStatesInCS
		for(ConcernLevels : compositeState.concernlevel)
		{
			
			count = count+1
		}
		
		for(ConcernLevels : compositeState.concernlevel)
		{
			if (count>1)
				StatesInCS += ConcernLevels.name + " + "	
			else 
				StatesInCS += ConcernLevels.name +"  "
		}
		return StatesInCS.subSequence(0, StatesInCS.length-2)
	}


	//Constraints that activate target states on event occurence
  	def FullTransitionConstraints (FullTransition transition)
	{
		val builder = new StringConcatenation();	
		var event = transition.event
		var expEvent = event.evOcc
		var stateEvent = event.sttOcc
		var operator = event.operator
		var targetState = transition.targetState
		var state= transition.state
		builder.append("constraint ((")
		if (expEvent !=null)
		{
			builder.append(expEvent.getNode.getTokenText)
		}
		if (operator !=null)
		{
			builder.append(operator)
		}
		if (stateEvent!=null)
		{
			for (states: stateEvent.stateExpression)
			{
				compile(states, builder)
			}
		}
		
		if (state!=null)
		{
			builder.append(") /\\ (" + state.name + "=1 )) -> "  + targetState.name + " = 1;")
		}
		else
		{
			builder.append(")) -> "  + targetState.name + " = 1;")
		}
		//builder.append(") /\\ (" + state.name + "=1 )) -> "  + targetState.name + " = 1;")
		builder.newLine()
		return builder
	}


	def compile(StateConstraint expression, StringConcatenation builder) {
		switch (expression) {
			Or_state: {
				compile(expression.left, builder) 
				builder.append(' \\/ ')
				compile(expression.ripe, builder) 
			}
			
			And_state: {
				compile(expression.left, builder) 
				builder.append(' /\\ ')
				compile(expression.ripe, builder)
			}
			
			stateNameRef: {
				builder.append(expression.value.name) builder.append('=1')
			}
		}
		return builder
	}



	//Constraints on start transitions
 	def StartTransitionConstraints (StartTransition startTransition)
 	{
 		val builder = new StringConcatenation();
 		//PROBLEM WITH START TRANSITION TO FIRST STATE
		//Get transition's parent composite state
		try 
		{
			val CompositeStateNodeString = startTransition.targetState.eContainer.eContainer.toString
			var nodeWords = CompositeStateNodeString.split(" ");
			val String[] lastWord = newArrayOfSize(1)
			for (String word : nodeWords) 
			{
				lastWord.set(0,word.toString)
			}
			var FirstParentCompositeState=(lastWord.get(0)).substring(0, (lastWord.get(0)).length()-1);//.substring(0, lastWord.length() - 1)
			
			//Get the state targeted by the transition
			val targetState = startTransition.targetState.name
			
			//Rule7: when a composite state is active, the state targeted by the start transition is activated, unless, rule3 is valid. 
			builder.append("constraint " + FirstParentCompositeState + " = 1 -> ("  + targetState+ " =1 ")		
			builder.append(startTransition.getSqStatesofTargetTransition)
			
		}
		catch (Exception e)
		{
			builder.append("constraint " + startTransition.targetState.name +" =1; ")
		}
		return builder
 	}
 	
 	
 	def getSqStatesofTargetTransition(StartTransition startTransition)
 	{
 		val builder = new StringConcatenation();
 		val concernLevel = startTransition.targetState.eContainer.eContents.toString
		var nodeWordsCL = concernLevel.split("name: ");
		var ContentSize = 0
		var GetterCount =1
 		for (String word : nodeWordsCL) 
			ContentSize=ContentSize+1
			
		
		if (ContentSize >2){
			builder.append("\\/ ")
			while(GetterCount<(ContentSize-1))
			{
				
				builder.append(nodeWordsCL.get(GetterCount).toString.split("\\)").get(0) + "+")
				GetterCount=GetterCount+1
			}
				builder.append(nodeWordsCL.get(ContentSize-1).toString.split("\\)").get(0) +"= 1);")	
		}
		else 
		{
			builder.append(");")
		}
		
  		return builder
 	}
 	
	
 	
 	def EndTransitionConstraints (EndTransition endTransition)
 	{
 		val builder = new StringConcatenation();	
 		val sourceState = endTransition.sourceState
		builder.append(" Start Transition : " +sourceState )
  		return builder
 	}
 	
 	
	//Multiple declaration of multi-instanciated variablesÒ
	def createCardinalities(Variable variable)
	{
		val builder = new StringConcatenation();	
		builder.append("array[1.." + Integer::parseInt(variable.isMultiInstanciated.maximum.get(0)) + "] of " + variable.TypeAllocation)
		return builder
	}

	//Assigns a type to the declaration of a variable
	def TypeAllocation (Variable variable)
	{
		val builder = new StringConcatenation();	
		if (variable.context == null)
		{
			builder.append("var ")
		}
		if (variable.domain != null)
		{
			builder.append(variable.domain.toString.subSequence(1, variable.domain.toString.length-1) +":")
		}
		else if (variable.inEnumeration != null)
		{
			builder.append((variable.values.toString).substring(1,((variable.values).toString).length()-1) +":")
		}
		else if (variable.varType == "Integer")
		{
			builder.append("int:")
		}
		else if (variable.varType == "Float")
		{
			builder.append("float:")
		}
		else if (variable.varType == "Boolean")
		{
			builder.append("0..1:")
		}
		return builder
	}
	
	
	
//	//To transform a string (the cardinality from variable.isMultiInstanciated.maximum) to an iterable from 0 to maximum
//	def CardinalityStringToIterable(Variable variable){
//		var count=0;
//		var maxCardinality=Integer::parseInt(variable.isMultiInstanciated.maximum.get(0));
//		var myIterable=newArrayOfSize(maxCardinality);
//		while (count<maxCardinality) {
//			myIterable.set(count, count+1);	
//			count=count+1;
//		}
//	return myIterable;
//	}
	
	//Collects and cocatenates constraints using a /\, except for the last one
	def getConstraints(SimpleConstraintState simpleConstraintState){
		var NumberOfConstraints=0;
		var ArraySetterCount=0;
		var ArrayReaderCount=1;
		val builder = new StringConcatenation();
		//collect the number of constraints in a simple state
		for (constraint:simpleConstraintState.constraint)
			NumberOfConstraints=NumberOfConstraints+1
		//create a list and fill with constraints
		var ConstraintList = newArrayOfSize(NumberOfConstraints);
		for (constraint:simpleConstraintState.constraint){
				ConstraintList.set(ArraySetterCount, (constraint.getNode.getTokenText));
				ArraySetterCount=ArraySetterCount+1;	
			}	
			
				
		//get first constraints
		builder.append("(" + ConstraintList.get(0)+ " )");
		//get the rest of the constraints and concatenate with /\
		while(ArrayReaderCount<ArraySetterCount){
			builder.append(" /\\");
			builder.append("(" + ConstraintList.get(ArrayReaderCount)+ " )");
			ArrayReaderCount=ArrayReaderCount+1;
		}
		return builder
	}
	
	//Delets void spaces between brackets and cardinality .. for quick fixes
	
	
	//
	
}
