/*
 * generated by Xtext 2.10.0
 */
package org.xtext.example.stateconstrainttransition.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.stateconstrainttransition.services.StateConstraintTransitionGrammarAccess;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.And_expr;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.And_state;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.Compare_expr;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.CompositeState;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.ConcernLevel;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.Constant;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.EndTransition;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.Event;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.EventOccurence;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.FullTransition;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.Log_expr;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.Max_Min;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.Model;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.Not;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.Or_expr;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.Or_state;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.SimpleConstraintState;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.StartTransition;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.StateConstraintTransitionPackage;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.StateOccurence;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.Var;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.Variable;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.VariableName;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.group_most_least;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.group_valuation;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.math_expr;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.multiple;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.stateNameRef;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.string;
import org.xtext.example.stateconstrainttransition.stateConstraintTransition.varEnumeration;

@SuppressWarnings("all")
public class StateConstraintTransitionSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private StateConstraintTransitionGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == StateConstraintTransitionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case StateConstraintTransitionPackage.AND_EXPR:
				sequence_And_expr(context, (And_expr) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.AND_STATE:
				sequence_And_state(context, (And_state) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.COMPARE_EXPR:
				sequence_Compare_expr(context, (Compare_expr) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.COMPOSITE_STATE:
				sequence_CompositeState(context, (CompositeState) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.CONCERN_LEVEL:
				sequence_ConcernLevel(context, (ConcernLevel) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.CONSTANT:
				sequence_Atomic(context, (Constant) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.END_TRANSITION:
				sequence_EndTransition(context, (EndTransition) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.EVENT_OCCURENCE:
				sequence_EventOccurence(context, (EventOccurence) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.FULL_TRANSITION:
				sequence_FullTransition(context, (FullTransition) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.LOG_EXPR:
				sequence_Log_expr(context, (Log_expr) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.MAX_MIN:
				sequence_Max_Min(context, (Max_Min) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.NOT:
				sequence_term(context, (Not) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.OR_EXPR:
				sequence_Or_expr(context, (Or_expr) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.OR_STATE:
				sequence_Or_state(context, (Or_state) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.SIMPLE_CONSTRAINT_STATE:
				sequence_SimpleConstraintState(context, (SimpleConstraintState) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.START_TRANSITION:
				sequence_StartTransition(context, (StartTransition) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.STATE_OCCURENCE:
				sequence_StateOccurence(context, (StateOccurence) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.VAR:
				sequence_Atomic(context, (Var) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.VARIABLE_NAME:
				sequence_VariableName(context, (VariableName) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.GROUP_MOST_LEAST:
				sequence_group_most_least(context, (group_most_least) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.GROUP_VALUATION:
				sequence_group_valuation(context, (group_valuation) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.MATH_EXPR:
				sequence_math_expr(context, (math_expr) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.MULTIPLE:
				sequence_multiple(context, (multiple) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.STATE_NAME_REF:
				sequence_StateName(context, (stateNameRef) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.STRING:
				sequence_Atomic(context, (string) semanticObject); 
				return; 
			case StateConstraintTransitionPackage.VAR_ENUMERATION:
				sequence_varEnumeration(context, (varEnumeration) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Constraint returns And_expr
	 *     Log_expr returns And_expr
	 *     Log_expr.Log_expr_1_0 returns And_expr
	 *     Or_expr returns And_expr
	 *     Or_expr.Or_expr_1_0 returns And_expr
	 *     And_expr returns And_expr
	 *     And_expr.And_expr_1_0 returns And_expr
	 *     Compare_expr returns And_expr
	 *     Compare_expr.Compare_expr_1_0 returns And_expr
	 *     math_expr returns And_expr
	 *     math_expr.math_expr_1_0 returns And_expr
	 *     term returns And_expr
	 *
	 * Constraint:
	 *     (left=And_expr_And_expr_1_0 right=Compare_expr)
	 */
	protected void sequence_And_expr(ISerializationContext context, And_expr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.AND_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.AND_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.AND_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.AND_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnd_exprAccess().getAnd_exprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAnd_exprAccess().getRightCompare_exprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StateConstraint returns And_state
	 *     Or_state returns And_state
	 *     Or_state.Or_state_1_0 returns And_state
	 *     And_state returns And_state
	 *     And_state.And_state_1_0 returns And_state
	 *
	 * Constraint:
	 *     (left=And_state_And_state_1_0 ripe=StateName)
	 */
	protected void sequence_And_state(ISerializationContext context, And_state semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.AND_STATE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.AND_STATE__LEFT));
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.AND_STATE__RIPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.AND_STATE__RIPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnd_stateAccess().getAnd_stateLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAnd_stateAccess().getRipeStateNameParserRuleCall_1_2_0(), semanticObject.getRipe());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Constant
	 *     Log_expr returns Constant
	 *     Log_expr.Log_expr_1_0 returns Constant
	 *     Or_expr returns Constant
	 *     Or_expr.Or_expr_1_0 returns Constant
	 *     And_expr returns Constant
	 *     And_expr.And_expr_1_0 returns Constant
	 *     Compare_expr returns Constant
	 *     Compare_expr.Compare_expr_1_0 returns Constant
	 *     math_expr returns Constant
	 *     math_expr.math_expr_1_0 returns Constant
	 *     term returns Constant
	 *     Atomic returns Constant
	 *
	 * Constraint:
	 *     value=Constant
	 */
	protected void sequence_Atomic(ISerializationContext context, Constant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueConstantParserRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Var
	 *     Log_expr returns Var
	 *     Log_expr.Log_expr_1_0 returns Var
	 *     Or_expr returns Var
	 *     Or_expr.Or_expr_1_0 returns Var
	 *     And_expr returns Var
	 *     And_expr.And_expr_1_0 returns Var
	 *     Compare_expr returns Var
	 *     Compare_expr.Compare_expr_1_0 returns Var
	 *     math_expr returns Var
	 *     math_expr.math_expr_1_0 returns Var
	 *     term returns Var
	 *     Atomic returns Var
	 *
	 * Constraint:
	 *     value=VariableName
	 */
	protected void sequence_Atomic(ISerializationContext context, Var semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.VAR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.VAR__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueVariableNameParserRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns string
	 *     Log_expr returns string
	 *     Log_expr.Log_expr_1_0 returns string
	 *     Or_expr returns string
	 *     Or_expr.Or_expr_1_0 returns string
	 *     And_expr returns string
	 *     And_expr.And_expr_1_0 returns string
	 *     Compare_expr returns string
	 *     Compare_expr.Compare_expr_1_0 returns string
	 *     math_expr returns string
	 *     math_expr.math_expr_1_0 returns string
	 *     term returns string
	 *     Atomic returns string
	 *
	 * Constraint:
	 *     value=strings
	 */
	protected void sequence_Atomic(ISerializationContext context, string semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueStringsParserRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Compare_expr
	 *     Log_expr returns Compare_expr
	 *     Log_expr.Log_expr_1_0 returns Compare_expr
	 *     Or_expr returns Compare_expr
	 *     Or_expr.Or_expr_1_0 returns Compare_expr
	 *     And_expr returns Compare_expr
	 *     And_expr.And_expr_1_0 returns Compare_expr
	 *     Compare_expr returns Compare_expr
	 *     Compare_expr.Compare_expr_1_0 returns Compare_expr
	 *     math_expr returns Compare_expr
	 *     math_expr.math_expr_1_0 returns Compare_expr
	 *     term returns Compare_expr
	 *
	 * Constraint:
	 *     (
	 *         left=Compare_expr_Compare_expr_1_0 
	 *         (
	 *             operator='>=' | 
	 *             operator='<=' | 
	 *             operator='=' | 
	 *             operator='!=' | 
	 *             operator='>' | 
	 *             operator='<'
	 *         ) 
	 *         right=math_expr
	 *     )
	 */
	protected void sequence_Compare_expr(ISerializationContext context, Compare_expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     State returns CompositeState
	 *     CompositeState returns CompositeState
	 *
	 * Constraint:
	 *     (type='compositeState' name=ID concernlevel+=ConcernLevel+ endCompositeState=[CompositeState|ID])
	 */
	protected void sequence_CompositeState(ISerializationContext context, CompositeState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConcernLevel returns ConcernLevel
	 *
	 * Constraint:
	 *     (name=ID state+=State+ endConcernLevel=[ConcernLevel|ID])
	 */
	protected void sequence_ConcernLevel(ISerializationContext context, ConcernLevel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Transition returns EndTransition
	 *     EndTransition returns EndTransition
	 *
	 * Constraint:
	 *     sourceState=[State|FQN]
	 */
	protected void sequence_EndTransition(ISerializationContext context, EndTransition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.END_TRANSITION__SOURCE_STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.END_TRANSITION__SOURCE_STATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEndTransitionAccess().getSourceStateStateFQNParserRuleCall_3_0_1(), semanticObject.getSourceState());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EventOccurence returns EventOccurence
	 *
	 * Constraint:
	 *     eventExpression+=Constraint
	 */
	protected void sequence_EventOccurence(ISerializationContext context, EventOccurence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns Event
	 *
	 * Constraint:
	 *     (evOcc=EventOccurence? (operator='\/' | operator='/\')? sttOcc=StateOccurence?)
	 */
	protected void sequence_Event(ISerializationContext context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Transition returns FullTransition
	 *     FullTransition returns FullTransition
	 *
	 * Constraint:
	 *     (state=[State|FQN]? event=Event sourceState=[State|FQN] targetState=[State|FQN])
	 */
	protected void sequence_FullTransition(ISerializationContext context, FullTransition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Log_expr
	 *     Log_expr returns Log_expr
	 *     Log_expr.Log_expr_1_0 returns Log_expr
	 *     Or_expr returns Log_expr
	 *     Or_expr.Or_expr_1_0 returns Log_expr
	 *     And_expr returns Log_expr
	 *     And_expr.And_expr_1_0 returns Log_expr
	 *     Compare_expr returns Log_expr
	 *     Compare_expr.Compare_expr_1_0 returns Log_expr
	 *     math_expr returns Log_expr
	 *     math_expr.math_expr_1_0 returns Log_expr
	 *     term returns Log_expr
	 *
	 * Constraint:
	 *     (left=Log_expr_Log_expr_1_0 (operator='->' | operator='<->' | operator='<-') right=Or_expr)
	 */
	protected void sequence_Log_expr(ISerializationContext context, Log_expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Max_Min
	 *     Log_expr returns Max_Min
	 *     Log_expr.Log_expr_1_0 returns Max_Min
	 *     Or_expr returns Max_Min
	 *     Or_expr.Or_expr_1_0 returns Max_Min
	 *     And_expr returns Max_Min
	 *     And_expr.And_expr_1_0 returns Max_Min
	 *     Compare_expr returns Max_Min
	 *     Compare_expr.Compare_expr_1_0 returns Max_Min
	 *     math_expr returns Max_Min
	 *     math_expr.math_expr_1_0 returns Max_Min
	 *     term returns Max_Min
	 *     GlobalConstraint returns Max_Min
	 *     Max_Min returns Max_Min
	 *
	 * Constraint:
	 *     (var=VariableName var=varEnumeration)
	 */
	protected void sequence_Max_Min(ISerializationContext context, Max_Min semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=ID variable+=Variable+ flexConstraints+=Constraint* state+=State+ transition+=Transition+)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Or_expr
	 *     Log_expr returns Or_expr
	 *     Log_expr.Log_expr_1_0 returns Or_expr
	 *     Or_expr returns Or_expr
	 *     Or_expr.Or_expr_1_0 returns Or_expr
	 *     And_expr returns Or_expr
	 *     And_expr.And_expr_1_0 returns Or_expr
	 *     Compare_expr returns Or_expr
	 *     Compare_expr.Compare_expr_1_0 returns Or_expr
	 *     math_expr returns Or_expr
	 *     math_expr.math_expr_1_0 returns Or_expr
	 *     term returns Or_expr
	 *
	 * Constraint:
	 *     (left=Or_expr_Or_expr_1_0 right=And_expr)
	 */
	protected void sequence_Or_expr(ISerializationContext context, Or_expr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.OR_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.OR_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.OR_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.OR_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOr_exprAccess().getOr_exprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOr_exprAccess().getRightAnd_exprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StateConstraint returns Or_state
	 *     Or_state returns Or_state
	 *     Or_state.Or_state_1_0 returns Or_state
	 *
	 * Constraint:
	 *     (left=Or_state_Or_state_1_0 ripe=And_state)
	 */
	protected void sequence_Or_state(ISerializationContext context, Or_state semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.OR_STATE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.OR_STATE__LEFT));
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.OR_STATE__RIPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.OR_STATE__RIPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOr_stateAccess().getOr_stateLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOr_stateAccess().getRipeAnd_stateParserRuleCall_1_2_0(), semanticObject.getRipe());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     State returns SimpleConstraintState
	 *     SimpleConstraintState returns SimpleConstraintState
	 *
	 * Constraint:
	 *     (type='simpleConstraintState' name=ID newVariable+=Variable* constraint+=Constraint+)
	 */
	protected void sequence_SimpleConstraintState(ISerializationContext context, SimpleConstraintState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Transition returns StartTransition
	 *     StartTransition returns StartTransition
	 *
	 * Constraint:
	 *     targetState=[State|FQN]
	 */
	protected void sequence_StartTransition(ISerializationContext context, StartTransition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.START_TRANSITION__TARGET_STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.START_TRANSITION__TARGET_STATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStartTransitionAccess().getTargetStateStateFQNParserRuleCall_3_0_1(), semanticObject.getTargetState());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StateConstraint returns stateNameRef
	 *     Or_state returns stateNameRef
	 *     Or_state.Or_state_1_0 returns stateNameRef
	 *     And_state returns stateNameRef
	 *     And_state.And_state_1_0 returns stateNameRef
	 *     StateName returns stateNameRef
	 *
	 * Constraint:
	 *     value=[State|FQN]
	 */
	protected void sequence_StateName(ISerializationContext context, stateNameRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.STATE_NAME_REF__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.STATE_NAME_REF__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStateNameAccess().getValueStateFQNParserRuleCall_1_0_1(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StateOccurence returns StateOccurence
	 *
	 * Constraint:
	 *     stateExpression+=StateConstraint
	 */
	protected void sequence_StateOccurence(ISerializationContext context, StateOccurence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableName returns VariableName
	 *
	 * Constraint:
	 *     (name=[Variable|ID] instance=IntValue?)
	 */
	protected void sequence_VariableName(ISerializationContext context, VariableName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (
	 *         varType=VarType 
	 *         context='Param'? 
	 *         inEnumeration='Enum'? 
	 *         name=ID 
	 *         isMultiInstanciated=multiple? 
	 *         domain=Domain? 
	 *         values+=Enumeration?
	 *     )
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns group_most_least
	 *     Log_expr returns group_most_least
	 *     Log_expr.Log_expr_1_0 returns group_most_least
	 *     Or_expr returns group_most_least
	 *     Or_expr.Or_expr_1_0 returns group_most_least
	 *     And_expr returns group_most_least
	 *     And_expr.And_expr_1_0 returns group_most_least
	 *     Compare_expr returns group_most_least
	 *     Compare_expr.Compare_expr_1_0 returns group_most_least
	 *     math_expr returns group_most_least
	 *     math_expr.math_expr_1_0 returns group_most_least
	 *     term returns group_most_least
	 *     GlobalConstraint returns group_most_least
	 *     group_most_least returns group_most_least
	 *
	 * Constraint:
	 *     (instances=IntValue variables=varEnumeration atomic=Atomic)
	 */
	protected void sequence_group_most_least(ISerializationContext context, group_most_least semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.GROUP_MOST_LEAST__INSTANCES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.GROUP_MOST_LEAST__INSTANCES));
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.GROUP_MOST_LEAST__VARIABLES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.GROUP_MOST_LEAST__VARIABLES));
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.GROUP_MOST_LEAST__ATOMIC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.GROUP_MOST_LEAST__ATOMIC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGroup_most_leastAccess().getInstancesIntValueParserRuleCall_1_0(), semanticObject.getInstances());
		feeder.accept(grammarAccess.getGroup_most_leastAccess().getVariablesVarEnumerationParserRuleCall_3_0(), semanticObject.getVariables());
		feeder.accept(grammarAccess.getGroup_most_leastAccess().getAtomicAtomicParserRuleCall_6_0(), semanticObject.getAtomic());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns group_valuation
	 *     Log_expr returns group_valuation
	 *     Log_expr.Log_expr_1_0 returns group_valuation
	 *     Or_expr returns group_valuation
	 *     Or_expr.Or_expr_1_0 returns group_valuation
	 *     And_expr returns group_valuation
	 *     And_expr.And_expr_1_0 returns group_valuation
	 *     Compare_expr returns group_valuation
	 *     Compare_expr.Compare_expr_1_0 returns group_valuation
	 *     math_expr returns group_valuation
	 *     math_expr.math_expr_1_0 returns group_valuation
	 *     term returns group_valuation
	 *     GlobalConstraint returns group_valuation
	 *     group_valuation returns group_valuation
	 *
	 * Constraint:
	 *     (var=varEnumeration atomic=Atomic)
	 */
	protected void sequence_group_valuation(ISerializationContext context, group_valuation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.GROUP_VALUATION__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.GROUP_VALUATION__VAR));
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.GROUP_VALUATION__ATOMIC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.GROUP_VALUATION__ATOMIC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGroup_valuationAccess().getVarVarEnumerationParserRuleCall_1_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getGroup_valuationAccess().getAtomicAtomicParserRuleCall_3_0(), semanticObject.getAtomic());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns math_expr
	 *     Log_expr returns math_expr
	 *     Log_expr.Log_expr_1_0 returns math_expr
	 *     Or_expr returns math_expr
	 *     Or_expr.Or_expr_1_0 returns math_expr
	 *     And_expr returns math_expr
	 *     And_expr.And_expr_1_0 returns math_expr
	 *     Compare_expr returns math_expr
	 *     Compare_expr.Compare_expr_1_0 returns math_expr
	 *     math_expr returns math_expr
	 *     math_expr.math_expr_1_0 returns math_expr
	 *     term returns math_expr
	 *
	 * Constraint:
	 *     (left=math_expr_math_expr_1_0 right=term)
	 */
	protected void sequence_math_expr(ISerializationContext context, math_expr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.MATH_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.MATH_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.MATH_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.MATH_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMath_exprAccess().getMath_exprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMath_exprAccess().getRightTermParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     multiple returns multiple
	 *
	 * Constraint:
	 *     (minimum+=min maximum+=max)
	 */
	protected void sequence_multiple(ISerializationContext context, multiple semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Not
	 *     Log_expr returns Not
	 *     Log_expr.Log_expr_1_0 returns Not
	 *     Or_expr returns Not
	 *     Or_expr.Or_expr_1_0 returns Not
	 *     And_expr returns Not
	 *     And_expr.And_expr_1_0 returns Not
	 *     Compare_expr returns Not
	 *     Compare_expr.Compare_expr_1_0 returns Not
	 *     math_expr returns Not
	 *     math_expr.math_expr_1_0 returns Not
	 *     term returns Not
	 *
	 * Constraint:
	 *     Constraint=term
	 */
	protected void sequence_term(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateConstraintTransitionPackage.Literals.NOT__CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateConstraintTransitionPackage.Literals.NOT__CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTermAccess().getConstraintTermParserRuleCall_1_2_0(), semanticObject.getConstraint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     varEnumeration returns varEnumeration
	 *
	 * Constraint:
	 *     (varName=VariableName varName=VariableName+)
	 */
	protected void sequence_varEnumeration(ISerializationContext context, varEnumeration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
